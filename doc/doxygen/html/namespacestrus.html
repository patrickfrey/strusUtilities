<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>strusUtilities: strus Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">strusUtilities
   &#160;<span id="projectnumber">0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">strus Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>strus toplevel namespace  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac388811dc7b9e30963512fb5d5d9991f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#ac388811dc7b9e30963512fb5d5d9991f">loadDocumentAnalyzerProgram</a> (DocumentAnalyzerInterface &amp;analyzer, const TextProcessorInterface *textproc, const std::string &amp;source)</td></tr>
<tr class="memdesc:ac388811dc7b9e30963512fb5d5d9991f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a document analyzer program from source.  <a href="#ac388811dc7b9e30963512fb5d5d9991f">More...</a><br/></td></tr>
<tr class="separator:ac388811dc7b9e30963512fb5d5d9991f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d484d34983a957cd3ec0cce0e4dcc0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a1d484d34983a957cd3ec0cce0e4dcc0e">loadQueryAnalyzerProgram</a> (QueryAnalyzerInterface &amp;analyzer, const TextProcessorInterface *textproc, const std::string &amp;source)</td></tr>
<tr class="memdesc:a1d484d34983a957cd3ec0cce0e4dcc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a query analyzer program from source.  <a href="#a1d484d34983a957cd3ec0cce0e4dcc0e">More...</a><br/></td></tr>
<tr class="separator:a1d484d34983a957cd3ec0cce0e4dcc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36ee5dd03da94f559e78fb5df6fc714"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#ac36ee5dd03da94f559e78fb5df6fc714">loadQueryAnalyzerPhraseType</a> (QueryAnalyzerInterface &amp;analyzer, const TextProcessorInterface *textproc, const std::string &amp;phrasetype, const std::string &amp;featuretype, const std::string &amp;normalizersrc, const std::string &amp;tokenizersrc)</td></tr>
<tr class="memdesc:ac36ee5dd03da94f559e78fb5df6fc714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a phrase type definition from its source components.  <a href="#ac36ee5dd03da94f559e78fb5df6fc714">More...</a><br/></td></tr>
<tr class="separator:ac36ee5dd03da94f559e78fb5df6fc714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179c609f8b8509055e58801a11c631b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a179c609f8b8509055e58801a11c631b5">loadQueryEvalProgram</a> (QueryEvalInterface &amp;qeval, const QueryProcessorInterface *qproc, const std::string &amp;source)</td></tr>
<tr class="memdesc:a179c609f8b8509055e58801a11c631b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a query evaluation program from source.  <a href="#a179c609f8b8509055e58801a11c631b5">More...</a><br/></td></tr>
<tr class="separator:a179c609f8b8509055e58801a11c631b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49844064c435ebd8d6f63fbdbe7d86ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a49844064c435ebd8d6f63fbdbe7d86ba">loadQuery</a> (QueryInterface &amp;query, const QueryAnalyzerInterface *analyzer, const QueryProcessorInterface *qproc, const std::string &amp;source)</td></tr>
<tr class="memdesc:a49844064c435ebd8d6f63fbdbe7d86ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a query from source (query language)  <a href="#a49844064c435ebd8d6f63fbdbe7d86ba">More...</a><br/></td></tr>
<tr class="separator:a49844064c435ebd8d6f63fbdbe7d86ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dc11bdf897937b4d299ea04c16a70b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a81dc11bdf897937b4d299ea04c16a70b">scanNextProgram</a> (std::string &amp;segment, std::string::const_iterator &amp;itr, const std::string::const_iterator &amp;end)</td></tr>
<tr class="memdesc:a81dc11bdf897937b4d299ea04c16a70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan a source for the next program segment in a source that contains multiple programs. The programs are separated by "\r\n.\r\n" or "\n.\n". No escaping of this sequence possible.  <a href="#a81dc11bdf897937b4d299ea04c16a70b">More...</a><br/></td></tr>
<tr class="separator:a81dc11bdf897937b4d299ea04c16a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea3e50fb506574b87482fa4d9395130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a0ea3e50fb506574b87482fa4d9395130">loadGlobalStatistics</a> (StorageClientInterface &amp;storage, const std::string &amp;file)</td></tr>
<tr class="memdesc:a0ea3e50fb506574b87482fa4d9395130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the global statistics for a storage from a stream.  <a href="#a0ea3e50fb506574b87482fa4d9395130">More...</a><br/></td></tr>
<tr class="separator:a0ea3e50fb506574b87482fa4d9395130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07612ff516a0060b5553be16ab2189d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#aa07612ff516a0060b5553be16ab2189d">loadDocumentMetaDataAssignments</a> (StorageClientInterface &amp;storage, const std::string &amp;metadataName, const std::string &amp;file, unsigned int commitsize=0)</td></tr>
<tr class="memdesc:aa07612ff516a0060b5553be16ab2189d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load some meta data assignments for a storage from a stream.  <a href="#aa07612ff516a0060b5553be16ab2189d">More...</a><br/></td></tr>
<tr class="separator:aa07612ff516a0060b5553be16ab2189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97273a58853126ce38dc3b9b869dec3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#ad97273a58853126ce38dc3b9b869dec3">loadDocumentAttributeAssignments</a> (StorageClientInterface &amp;storage, const std::string &amp;attributeName, const std::string &amp;file, unsigned int commitsize=0)</td></tr>
<tr class="memdesc:ad97273a58853126ce38dc3b9b869dec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load some attribute assignments for a storage from a stream.  <a href="#ad97273a58853126ce38dc3b9b869dec3">More...</a><br/></td></tr>
<tr class="separator:ad97273a58853126ce38dc3b9b869dec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15b8cc704d45d80d179f874a95d9efa"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#ab15b8cc704d45d80d179f874a95d9efa">loadDocumentUserRightsAssignments</a> (StorageClientInterface &amp;storage, const std::string &amp;file, unsigned int commitsize=0)</td></tr>
<tr class="memdesc:ab15b8cc704d45d80d179f874a95d9efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load some user rights assignments for a storage from a stream.  <a href="#ab15b8cc704d45d80d179f874a95d9efa">More...</a><br/></td></tr>
<tr class="separator:ab15b8cc704d45d80d179f874a95d9efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>strus toplevel namespace </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac388811dc7b9e30963512fb5d5d9991f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void strus::loadDocumentAnalyzerProgram </td>
          <td>(</td>
          <td class="paramtype">DocumentAnalyzerInterface &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextProcessorInterface *&#160;</td>
          <td class="paramname"><em>textproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a document analyzer program from source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">analyzer</td><td>analyzer program to instatiate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textproc</td><td>provider for text processing functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The grammar of the analyzer program source is defined <a href="http://www.project-strus.net/grammar_analyerprg.htm">here</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad97273a58853126ce38dc3b9b869dec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int strus::loadDocumentAttributeAssignments </td>
          <td>(</td>
          <td class="paramtype">StorageClientInterface &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attributeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>commitsize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load some attribute assignments for a storage from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">storage</td><td>the storage to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributeName</td><td>name of the attribute to assign </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commitsize</td><td>number of documents to update until an implicit commit is called (0 =&gt; no implicit commit) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of documents (non distinct) updated </dd></dl>

</div>
</div>
<a class="anchor" id="aa07612ff516a0060b5553be16ab2189d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int strus::loadDocumentMetaDataAssignments </td>
          <td>(</td>
          <td class="paramtype">StorageClientInterface &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metadataName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>commitsize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load some meta data assignments for a storage from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">storage</td><td>the storage to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadataName</td><td>name of the meta data field to assign </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commitsize</td><td>number of documents to update until an implicit commit is called (0 =&gt; no implicit commit) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of documents (non distinct) updated </dd></dl>

</div>
</div>
<a class="anchor" id="ab15b8cc704d45d80d179f874a95d9efa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int strus::loadDocumentUserRightsAssignments </td>
          <td>(</td>
          <td class="paramtype">StorageClientInterface &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>commitsize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load some user rights assignments for a storage from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">storage</td><td>the storage to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commitsize</td><td>number of documents to update until an implicit commit is called (0 =&gt; no implicit commit) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of documents (non distinct) updated </dd></dl>

</div>
</div>
<a class="anchor" id="a0ea3e50fb506574b87482fa4d9395130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void strus::loadGlobalStatistics </td>
          <td>(</td>
          <td class="paramtype">StorageClientInterface &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the global statistics for a storage from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">storage</td><td>the storage to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the file to read from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49844064c435ebd8d6f63fbdbe7d86ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void strus::loadQuery </td>
          <td>(</td>
          <td class="paramtype">QueryInterface &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryAnalyzerInterface *&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryProcessorInterface *&#160;</td>
          <td class="paramname"><em>qproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a query from source (query language) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">query</td><td>query interface to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analyzer</td><td>program for analyzing text segments in the query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qproc</td><td>query processor interface for info about objects loaded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac36ee5dd03da94f559e78fb5df6fc714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void strus::loadQueryAnalyzerPhraseType </td>
          <td>(</td>
          <td class="paramtype">QueryAnalyzerInterface &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextProcessorInterface *&#160;</td>
          <td class="paramname"><em>textproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>phrasetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>featuretype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>normalizersrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tokenizersrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a phrase type definition from its source components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">analyzer</td><td>program for analyzing text segments in the query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textproc</td><td>provider for text processing functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phrasetype</td><td>name of phrase type to define </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">featuretype</td><td>name of the feature type produced by the defined phrase type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalizersrc</td><td>source with normalizer definitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tokenizersrc</td><td>source with tokenizer definitions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d484d34983a957cd3ec0cce0e4dcc0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void strus::loadQueryAnalyzerProgram </td>
          <td>(</td>
          <td class="paramtype">QueryAnalyzerInterface &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextProcessorInterface *&#160;</td>
          <td class="paramname"><em>textproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a query analyzer program from source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">analyzer</td><td>analyzer program to instatiate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textproc</td><td>provider for text processing functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a179c609f8b8509055e58801a11c631b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void strus::loadQueryEvalProgram </td>
          <td>(</td>
          <td class="paramtype">QueryEvalInterface &amp;&#160;</td>
          <td class="paramname"><em>qeval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryProcessorInterface *&#160;</td>
          <td class="paramname"><em>qproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a query evaluation program from source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qeval</td><td>query evaluation interface to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qproc</td><td>query processor interface for info about objects loaded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81dc11bdf897937b4d299ea04c16a70b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::scanNextProgram </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>itr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan a source for the next program segment in a source that contains multiple programs. The programs are separated by "\r\n.\r\n" or "\n.\n". No escaping of this sequence possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">segment</td><td>the program segment scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itr</td><td>scanning iterator on a source containing one or multiple programs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>end iterator of the source to scan </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if there was a segment left to scan </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is mainly used for loading test programs </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The scanner skips whitespaces at the start of each program segment and returns initial end of line that belongs to the separator. So whitespaces should have no meaning in the languages of the programs loaded this way. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 12 2015 22:32:56 for strusUtilities by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
