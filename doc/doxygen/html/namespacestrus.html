<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>strusUtilities: strus Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">strusUtilities
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">strus Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>strus toplevel namespace  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstrus_1_1AnalyzerMapElement.html">AnalyzerMapElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of one element of an analyzer map.  <a href="structstrus_1_1AnalyzerMapElement.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad91bcc52f1fd526b856ef54e31f8a105"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#ad91bcc52f1fd526b856ef54e31f8a105">loadDocumentAnalyzerProgram</a> (DocumentAnalyzerInterface &amp;analyzer, const TextProcessorInterface *textproc, const std::string &amp;source, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:ad91bcc52f1fd526b856ef54e31f8a105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a document analyzer program from source.  <a href="#ad91bcc52f1fd526b856ef54e31f8a105">More...</a><br/></td></tr>
<tr class="separator:ad91bcc52f1fd526b856ef54e31f8a105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257998f8c792b16e3ba7747fe11c5aa0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a257998f8c792b16e3ba7747fe11c5aa0">loadQueryAnalyzerProgram</a> (QueryAnalyzerInterface &amp;analyzer, const TextProcessorInterface *textproc, const std::string &amp;source, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a257998f8c792b16e3ba7747fe11c5aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a query analyzer program from source.  <a href="#a257998f8c792b16e3ba7747fe11c5aa0">More...</a><br/></td></tr>
<tr class="separator:a257998f8c792b16e3ba7747fe11c5aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3cdb850c577e94e935c468d38afc01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a2b3cdb850c577e94e935c468d38afc01">loadQueryAnalyzerPhraseType</a> (QueryAnalyzerInterface &amp;analyzer, const TextProcessorInterface *textproc, const std::string &amp;phrasetype, const std::string &amp;featuretype, const std::string &amp;normalizersrc, const std::string &amp;tokenizersrc, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a2b3cdb850c577e94e935c468d38afc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a phrase type definition from its source components.  <a href="#a2b3cdb850c577e94e935c468d38afc01">More...</a><br/></td></tr>
<tr class="separator:a2b3cdb850c577e94e935c468d38afc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55f0e2ac388f36cd6c8619fcb781d24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#ae55f0e2ac388f36cd6c8619fcb781d24">isAnalyzerMapSource</a> (const std::string &amp;source, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:ae55f0e2ac388f36cd6c8619fcb781d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if 'source' is most likely a source describing an analyzer map.  <a href="#ae55f0e2ac388f36cd6c8619fcb781d24">More...</a><br/></td></tr>
<tr class="separator:ae55f0e2ac388f36cd6c8619fcb781d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8daefcff986cdaf50262c9b0e354fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a0a8daefcff986cdaf50262c9b0e354fb">loadAnalyzerMap</a> (std::vector&lt; <a class="el" href="structstrus_1_1AnalyzerMapElement.html">AnalyzerMapElement</a> &gt; &amp;mapdef, const std::string &amp;source, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a0a8daefcff986cdaf50262c9b0e354fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a map of definitions describing how different document types are mapped to an analyzer program.  <a href="#a0a8daefcff986cdaf50262c9b0e354fb">More...</a><br/></td></tr>
<tr class="separator:a0a8daefcff986cdaf50262c9b0e354fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c408e2a3a2997f1557a19489368050"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a94c408e2a3a2997f1557a19489368050">loadQueryEvalProgram</a> (QueryEvalInterface &amp;qeval, const QueryProcessorInterface *qproc, const std::string &amp;source, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a94c408e2a3a2997f1557a19489368050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a query evaluation program from source.  <a href="#a94c408e2a3a2997f1557a19489368050">More...</a><br/></td></tr>
<tr class="separator:a94c408e2a3a2997f1557a19489368050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea5e58cd742d444c7d56a06642908c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a8ea5e58cd742d444c7d56a06642908c7">loadQuery</a> (QueryInterface &amp;query, const QueryAnalyzerInterface *analyzer, const QueryProcessorInterface *qproc, const std::string &amp;source, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a8ea5e58cd742d444c7d56a06642908c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a query from source (query language)  <a href="#a8ea5e58cd742d444c7d56a06642908c7">More...</a><br/></td></tr>
<tr class="separator:a8ea5e58cd742d444c7d56a06642908c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4176074a811b447a92cf49bcb9e71e4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a4176074a811b447a92cf49bcb9e71e4b">scanNextProgram</a> (std::string &amp;segment, std::string::const_iterator &amp;itr, const std::string::const_iterator &amp;end, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a4176074a811b447a92cf49bcb9e71e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan a source for the next program segment in a source that contains multiple programs. The programs are separated by "\r\n.\r\n" or "\n.\n". No escaping of this sequence possible.  <a href="#a4176074a811b447a92cf49bcb9e71e4b">More...</a><br/></td></tr>
<tr class="separator:a4176074a811b447a92cf49bcb9e71e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba06c4f42496f638a2013a15f9c2de63"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#aba06c4f42496f638a2013a15f9c2de63">loadDocumentMetaDataAssignments</a> (StorageClientInterface &amp;storage, const std::string &amp;metadataName, const std::string &amp;file, unsigned int commitsize, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:aba06c4f42496f638a2013a15f9c2de63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load some meta data assignments for a storage from a stream.  <a href="#aba06c4f42496f638a2013a15f9c2de63">More...</a><br/></td></tr>
<tr class="separator:aba06c4f42496f638a2013a15f9c2de63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d0d09698889f14a1cde6ce29423dab"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a24d0d09698889f14a1cde6ce29423dab">loadDocumentAttributeAssignments</a> (StorageClientInterface &amp;storage, const std::string &amp;attributeName, const std::string &amp;file, unsigned int commitsize, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a24d0d09698889f14a1cde6ce29423dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load some attribute assignments for a storage from a stream.  <a href="#a24d0d09698889f14a1cde6ce29423dab">More...</a><br/></td></tr>
<tr class="separator:a24d0d09698889f14a1cde6ce29423dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d641ac16251625126db01c15368556b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a5d641ac16251625126db01c15368556b">loadDocumentUserRightsAssignments</a> (StorageClientInterface &amp;storage, const std::string &amp;file, unsigned int commitsize, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a5d641ac16251625126db01c15368556b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load some user rights assignments for a storage from a stream.  <a href="#a5d641ac16251625126db01c15368556b">More...</a><br/></td></tr>
<tr class="separator:a5d641ac16251625126db01c15368556b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>strus toplevel namespace </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae55f0e2ac388f36cd6c8619fcb781d24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::isAnalyzerMapSource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if 'source' is most likely a source describing an analyzer map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source candidate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if yes, false, else </dd></dl>

</div>
</div>
<a class="anchor" id="a0a8daefcff986cdaf50262c9b0e354fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadAnalyzerMap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; AnalyzerMapElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapdef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a map of definitions describing how different document types are mapped to an analyzer program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapdef</td><td>list of definitions to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source with definitions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ad91bcc52f1fd526b856ef54e31f8a105"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadDocumentAnalyzerProgram </td>
          <td>(</td>
          <td class="paramtype">DocumentAnalyzerInterface &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextProcessorInterface *&#160;</td>
          <td class="paramname"><em>textproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a document analyzer program from source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">analyzer</td><td>analyzer program to instatiate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textproc</td><td>provider for text processing functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The grammar of the analyzer program source is defined <a href="http://www.project-strus.net/grammar_analyerprg.htm">here</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a24d0d09698889f14a1cde6ce29423dab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int strus::loadDocumentAttributeAssignments </td>
          <td>(</td>
          <td class="paramtype">StorageClientInterface &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attributeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>commitsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load some attribute assignments for a storage from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">storage</td><td>the storage to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributeName</td><td>name of the attribute to assign </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commitsize</td><td>number of documents to update until an implicit commit is called (0 =&gt; no implicit commit) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of documents (non distinct) updated </dd></dl>

</div>
</div>
<a class="anchor" id="aba06c4f42496f638a2013a15f9c2de63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int strus::loadDocumentMetaDataAssignments </td>
          <td>(</td>
          <td class="paramtype">StorageClientInterface &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metadataName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>commitsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load some meta data assignments for a storage from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">storage</td><td>the storage to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadataName</td><td>name of the meta data field to assign </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commitsize</td><td>number of documents to update until an implicit commit is called (0 =&gt; no implicit commit) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of documents (non distinct) updated </dd></dl>

</div>
</div>
<a class="anchor" id="a5d641ac16251625126db01c15368556b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int strus::loadDocumentUserRightsAssignments </td>
          <td>(</td>
          <td class="paramtype">StorageClientInterface &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>commitsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load some user rights assignments for a storage from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">storage</td><td>the storage to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commitsize</td><td>number of documents to update until an implicit commit is called (0 =&gt; no implicit commit) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of documents (non distinct) updated </dd></dl>

</div>
</div>
<a class="anchor" id="a8ea5e58cd742d444c7d56a06642908c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadQuery </td>
          <td>(</td>
          <td class="paramtype">QueryInterface &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryAnalyzerInterface *&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryProcessorInterface *&#160;</td>
          <td class="paramname"><em>qproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a query from source (query language) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">query</td><td>query interface to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analyzer</td><td>program for analyzing text segments in the query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qproc</td><td>query processor interface for info about objects loaded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a2b3cdb850c577e94e935c468d38afc01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadQueryAnalyzerPhraseType </td>
          <td>(</td>
          <td class="paramtype">QueryAnalyzerInterface &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextProcessorInterface *&#160;</td>
          <td class="paramname"><em>textproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>phrasetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>featuretype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>normalizersrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tokenizersrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a phrase type definition from its source components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">analyzer</td><td>program for analyzing text segments in the query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textproc</td><td>provider for text processing functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phrasetype</td><td>name of phrase type to define </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">featuretype</td><td>name of the feature type produced by the defined phrase type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalizersrc</td><td>source with normalizer definitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tokenizersrc</td><td>source with tokenizer definitions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a257998f8c792b16e3ba7747fe11c5aa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadQueryAnalyzerProgram </td>
          <td>(</td>
          <td class="paramtype">QueryAnalyzerInterface &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextProcessorInterface *&#160;</td>
          <td class="paramname"><em>textproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a query analyzer program from source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">analyzer</td><td>analyzer program to instatiate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textproc</td><td>provider for text processing functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a94c408e2a3a2997f1557a19489368050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadQueryEvalProgram </td>
          <td>(</td>
          <td class="paramtype">QueryEvalInterface &amp;&#160;</td>
          <td class="paramname"><em>qeval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryProcessorInterface *&#160;</td>
          <td class="paramname"><em>qproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a query evaluation program from source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qeval</td><td>query evaluation interface to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qproc</td><td>query processor interface for info about objects loaded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a4176074a811b447a92cf49bcb9e71e4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::scanNextProgram </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>itr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan a source for the next program segment in a source that contains multiple programs. The programs are separated by "\r\n.\r\n" or "\n.\n". No escaping of this sequence possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">segment</td><td>the program segment scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itr</td><td>scanning iterator on a source containing one or multiple programs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>end iterator of the source to scan </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if there was a segment left to scan </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is mainly used for loading test programs </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The scanner skips whitespaces at the start of each program segment and returns initial end of line that belongs to the separator. So whitespaces should have no meaning in the languages of the programs loaded this way. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Nov 13 2015 00:42:40 for strusUtilities by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
