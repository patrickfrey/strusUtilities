<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>strusUtilities: strus Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">strusUtilities
   &#160;<span id="projectnumber">0.13</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">strus Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>strus toplevel namespace  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstrus_1_1QueryDescriptors.html">QueryDescriptors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some default settings for parsing and building the query.  <a href="structstrus_1_1QueryDescriptors.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstrus_1_1AnalyzerMapElement.html">AnalyzerMapElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of one element of an analyzer map.  <a href="structstrus_1_1AnalyzerMapElement.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab17736a5d8508d0003040da5f6cb6512"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#ab17736a5d8508d0003040da5f6cb6512">loadDocumentAnalyzerProgram</a> (DocumentAnalyzerInterface &amp;analyzer, const TextProcessorInterface *textproc, const std::string &amp;source, bool allowIncludes, std::ostream &amp;warnings, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:ab17736a5d8508d0003040da5f6cb6512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a document analyzer program from source.  <a href="#ab17736a5d8508d0003040da5f6cb6512">More...</a><br/></td></tr>
<tr class="separator:ab17736a5d8508d0003040da5f6cb6512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8792ff139b68a606cf703dc3121ee5b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a8792ff139b68a606cf703dc3121ee5b8">loadQueryAnalyzerProgram</a> (QueryAnalyzerInterface &amp;analyzer, <a class="el" href="structstrus_1_1QueryDescriptors.html">QueryDescriptors</a> &amp;qdescr, const TextProcessorInterface *textproc, const std::string &amp;source, bool allowIncludes, std::ostream &amp;warnings, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a8792ff139b68a606cf703dc3121ee5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a query analyzer program from source.  <a href="#a8792ff139b68a606cf703dc3121ee5b8">More...</a><br/></td></tr>
<tr class="separator:a8792ff139b68a606cf703dc3121ee5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55f0e2ac388f36cd6c8619fcb781d24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#ae55f0e2ac388f36cd6c8619fcb781d24">isAnalyzerMapSource</a> (const std::string &amp;source, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:ae55f0e2ac388f36cd6c8619fcb781d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if 'source' is most likely a source describing an analyzer map.  <a href="#ae55f0e2ac388f36cd6c8619fcb781d24">More...</a><br/></td></tr>
<tr class="separator:ae55f0e2ac388f36cd6c8619fcb781d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8daefcff986cdaf50262c9b0e354fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a0a8daefcff986cdaf50262c9b0e354fb">loadAnalyzerMap</a> (std::vector&lt; <a class="el" href="structstrus_1_1AnalyzerMapElement.html">AnalyzerMapElement</a> &gt; &amp;mapdef, const std::string &amp;source, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a0a8daefcff986cdaf50262c9b0e354fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a map of definitions describing how different document types are mapped to an analyzer program.  <a href="#a0a8daefcff986cdaf50262c9b0e354fb">More...</a><br/></td></tr>
<tr class="separator:a0a8daefcff986cdaf50262c9b0e354fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcc86bc935dfede4346a5811764f88a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a3bcc86bc935dfede4346a5811764f88a">loadQueryEvalProgram</a> (QueryEvalInterface &amp;qeval, <a class="el" href="structstrus_1_1QueryDescriptors.html">QueryDescriptors</a> &amp;qdescr, const QueryProcessorInterface *qproc, const std::string &amp;source, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a3bcc86bc935dfede4346a5811764f88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a query evaluation program from source.  <a href="#a3bcc86bc935dfede4346a5811764f88a">More...</a><br/></td></tr>
<tr class="separator:a3bcc86bc935dfede4346a5811764f88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ae7a430f337b1d2ac6a2aa098fb71f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#ab3ae7a430f337b1d2ac6a2aa098fb71f">loadQuery</a> (QueryInterface &amp;query, const QueryAnalyzerInterface *analyzer, const QueryProcessorInterface *qproc, const std::string &amp;source, const <a class="el" href="structstrus_1_1QueryDescriptors.html">QueryDescriptors</a> &amp;qdescr, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:ab3ae7a430f337b1d2ac6a2aa098fb71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a query from source (query language)  <a href="#ab3ae7a430f337b1d2ac6a2aa098fb71f">More...</a><br/></td></tr>
<tr class="separator:ab3ae7a430f337b1d2ac6a2aa098fb71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf0bda4743606823af4d67dff0a4f6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#adcf0bda4743606823af4d67dff0a4f6f">loadPhraseAnalyzer</a> (QueryAnalyzerInterface &amp;analyzer, const TextProcessorInterface *textproc, const std::string &amp;normalizersrc, const std::string &amp;tokenizersrc, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:adcf0bda4743606823af4d67dff0a4f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a simple query analyzer config for one field (name "") producing one feature type ("")  <a href="#adcf0bda4743606823af4d67dff0a4f6f">More...</a><br/></td></tr>
<tr class="separator:adcf0bda4743606823af4d67dff0a4f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4176074a811b447a92cf49bcb9e71e4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a4176074a811b447a92cf49bcb9e71e4b">scanNextProgram</a> (std::string &amp;segment, std::string::const_iterator &amp;itr, const std::string::const_iterator &amp;end, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a4176074a811b447a92cf49bcb9e71e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan a source for the next program segment in a source that contains multiple programs. The programs are separated by "\r\n.\r\n" or "\n.\n". No escaping of this sequence possible.  <a href="#a4176074a811b447a92cf49bcb9e71e4b">More...</a><br/></td></tr>
<tr class="separator:a4176074a811b447a92cf49bcb9e71e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b52d5233d28065fa06fa337f466e0e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a26b52d5233d28065fa06fa337f466e0e">loadDocumentMetaDataAssignments</a> (StorageClientInterface &amp;storage, const std::string &amp;metadataName, const std::multimap&lt; std::string, strus::Index &gt; *attributemapref, const std::string &amp;file, unsigned int commitsize, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a26b52d5233d28065fa06fa337f466e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load some meta data assignments for a storage from a stream.  <a href="#a26b52d5233d28065fa06fa337f466e0e">More...</a><br/></td></tr>
<tr class="separator:a26b52d5233d28065fa06fa337f466e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accebc70cecdda8195ce2630aeb9adddf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#accebc70cecdda8195ce2630aeb9adddf">loadDocumentAttributeAssignments</a> (StorageClientInterface &amp;storage, const std::string &amp;attributeName, const std::multimap&lt; std::string, strus::Index &gt; *attributemapref, const std::string &amp;file, unsigned int commitsize, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:accebc70cecdda8195ce2630aeb9adddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load some attribute assignments for a storage from a stream.  <a href="#accebc70cecdda8195ce2630aeb9adddf">More...</a><br/></td></tr>
<tr class="separator:accebc70cecdda8195ce2630aeb9adddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4cb223c5e326d78ef241799196a80c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a2e4cb223c5e326d78ef241799196a80c">loadDocumentUserRightsAssignments</a> (StorageClientInterface &amp;storage, const std::multimap&lt; std::string, strus::Index &gt; *attributemapref, const std::string &amp;file, unsigned int commitsize, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a2e4cb223c5e326d78ef241799196a80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load some user rights assignments for a storage from a stream.  <a href="#a2e4cb223c5e326d78ef241799196a80c">More...</a><br/></td></tr>
<tr class="separator:a2e4cb223c5e326d78ef241799196a80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab396cf48e1a280e8fe00cd20a2500a70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#ab396cf48e1a280e8fe00cd20a2500a70">parseDocumentClass</a> (analyzer::DocumentClass &amp;result, const std::string &amp;source, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:ab396cf48e1a280e8fe00cd20a2500a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a document class from a declaration like 'content="application/xml"; charset=UTF-8"'.  <a href="#ab396cf48e1a280e8fe00cd20a2500a70">More...</a><br/></td></tr>
<tr class="separator:ab396cf48e1a280e8fe00cd20a2500a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9de377a99129c479c1c3e9eb0a88d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a8f9de377a99129c479c1c3e9eb0a88d9">loadVectorStorageVectors</a> (VectorStorageClientInterface *vstorage, const std::string &amp;vectorfile, ErrorBufferInterface *errorhnd)</td></tr>
<tr class="memdesc:a8f9de377a99129c479c1c3e9eb0a88d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the feature definitions in the file with path vectorfile to a vector storage.  <a href="#a8f9de377a99129c479c1c3e9eb0a88d9">More...</a><br/></td></tr>
<tr class="separator:a8f9de377a99129c479c1c3e9eb0a88d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bba25a8e57d7d066c08f69d325ffbf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a6bba25a8e57d7d066c08f69d325ffbf3">loadPatternMatcherProgramWithLexer</a> (PatternLexerInstanceInterface *lexer, PatternMatcherInstanceInterface *matcher, const std::string &amp;source, ErrorBufferInterface *errorhnd, std::vector&lt; std::string &gt; &amp;warnings)</td></tr>
<tr class="memdesc:a6bba25a8e57d7d066c08f69d325ffbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and compiles a list of pattern matcher programs from source and instruments a lexer and a matcher instance with it.  <a href="#a6bba25a8e57d7d066c08f69d325ffbf3">More...</a><br/></td></tr>
<tr class="separator:a6bba25a8e57d7d066c08f69d325ffbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a78978ceade749384e816394471d23c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestrus.html#a6a78978ceade749384e816394471d23c">loadPatternMatcherProgramWithFeeder</a> (PatternTermFeederInstanceInterface *feeder, PatternMatcherInstanceInterface *matcher, const std::string &amp;source, ErrorBufferInterface *errorhnd, std::vector&lt; std::string &gt; &amp;warnings)</td></tr>
<tr class="memdesc:a6a78978ceade749384e816394471d23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and compiles a list of pattern matcher programs from source and instruments a term feeder for pattern matching as analyzer post processing and a matcher instance.  <a href="#a6a78978ceade749384e816394471d23c">More...</a><br/></td></tr>
<tr class="separator:a6a78978ceade749384e816394471d23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>strus toplevel namespace </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae55f0e2ac388f36cd6c8619fcb781d24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::isAnalyzerMapSource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if 'source' is most likely a source describing an analyzer map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source candidate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if yes, false, else </dd></dl>

</div>
</div>
<a class="anchor" id="a0a8daefcff986cdaf50262c9b0e354fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadAnalyzerMap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; AnalyzerMapElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapdef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a map of definitions describing how different document types are mapped to an analyzer program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapdef</td><td>list of definitions to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source with definitions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ab17736a5d8508d0003040da5f6cb6512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadDocumentAnalyzerProgram </td>
          <td>(</td>
          <td class="paramtype">DocumentAnalyzerInterface &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextProcessorInterface *&#160;</td>
          <td class="paramname"><em>textproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowIncludes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>warnings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a document analyzer program from source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">analyzer</td><td>analyzer program to instatiate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textproc</td><td>provider for text processing functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowIncludes</td><td>true if #include directives expanded, may be forbidden for security </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The grammar of the analyzer program source is defined <a href="http://www.project-strus.net/grammar_analyerprg.htm">here</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="accebc70cecdda8195ce2630aeb9adddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int strus::loadDocumentAttributeAssignments </td>
          <td>(</td>
          <td class="paramtype">StorageClientInterface &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attributeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::multimap&lt; std::string, strus::Index &gt; *&#160;</td>
          <td class="paramname"><em>attributemapref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>commitsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load some attribute assignments for a storage from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">storage</td><td>the storage to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributeName</td><td>name of the attribute to assign </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributemapref</td><td>map that maps the update key to a list of document numbers to update (NULL, if the docid or docno is the key) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commitsize</td><td>number of documents to update until an implicit commit is called (0 =&gt; no implicit commit) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of documents (non distinct) updated </dd></dl>

</div>
</div>
<a class="anchor" id="a26b52d5233d28065fa06fa337f466e0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int strus::loadDocumentMetaDataAssignments </td>
          <td>(</td>
          <td class="paramtype">StorageClientInterface &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metadataName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::multimap&lt; std::string, strus::Index &gt; *&#160;</td>
          <td class="paramname"><em>attributemapref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>commitsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load some meta data assignments for a storage from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">storage</td><td>the storage to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadataName</td><td>name of the meta data field to assign </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributemapref</td><td>map that maps the update key to a list of document numbers to update (NULL, if the docid or docno is the key) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commitsize</td><td>number of documents to update until an implicit commit is called (0 =&gt; no implicit commit) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of documents (non distinct) updated </dd></dl>

</div>
</div>
<a class="anchor" id="a2e4cb223c5e326d78ef241799196a80c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int strus::loadDocumentUserRightsAssignments </td>
          <td>(</td>
          <td class="paramtype">StorageClientInterface &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::multimap&lt; std::string, strus::Index &gt; *&#160;</td>
          <td class="paramname"><em>attributemapref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>commitsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load some user rights assignments for a storage from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">storage</td><td>the storage to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributemapref</td><td>map that maps the update key to a list of document numbers to update (NULL, if the docid or docno is the key) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commitsize</td><td>number of documents to update until an implicit commit is called (0 =&gt; no implicit commit) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of documents (non distinct) updated </dd></dl>

</div>
</div>
<a class="anchor" id="a6a78978ceade749384e816394471d23c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadPatternMatcherProgramWithFeeder </td>
          <td>(</td>
          <td class="paramtype">PatternTermFeederInstanceInterface *&#160;</td>
          <td class="paramname"><em>feeder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PatternMatcherInstanceInterface *&#160;</td>
          <td class="paramname"><em>matcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>warnings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads and compiles a list of pattern matcher programs from source and instruments a term feeder for pattern matching as analyzer post processing and a matcher instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">feeder</td><td>feeder instance for analyzer output terms </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matcher</td><td>matcher instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source to parse </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warnings</td><td>warnings occurred </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a class="anchor" id="a6bba25a8e57d7d066c08f69d325ffbf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadPatternMatcherProgramWithLexer </td>
          <td>(</td>
          <td class="paramtype">PatternLexerInstanceInterface *&#160;</td>
          <td class="paramname"><em>lexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PatternMatcherInstanceInterface *&#160;</td>
          <td class="paramname"><em>matcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>warnings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads and compiles a list of pattern matcher programs from source and instruments a lexer and a matcher instance with it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lexer</td><td>lexer instance </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matcher</td><td>matcher instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source to parse </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warnings</td><td>warnings occurred </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a class="anchor" id="adcf0bda4743606823af4d67dff0a4f6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadPhraseAnalyzer </td>
          <td>(</td>
          <td class="paramtype">QueryAnalyzerInterface &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextProcessorInterface *&#160;</td>
          <td class="paramname"><em>textproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>normalizersrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tokenizersrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a simple query analyzer config for one field (name "") producing one feature type ("") </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">query</td><td>analyzer interface to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textproc</td><td>textprocessor to retrieve the functions loaded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalizersrc</td><td>source string (not a file name!) of the normalizers to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tokenizersrc</td><td>source string (not a file name!) of the tokenizer to parse </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This simplistic function is mainly intended for debugging and the program strusAnalyzePhrase that just checks the result of a tokenizer with some normalizers </dd></dl>

</div>
</div>
<a class="anchor" id="ab3ae7a430f337b1d2ac6a2aa098fb71f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadQuery </td>
          <td>(</td>
          <td class="paramtype">QueryInterface &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryAnalyzerInterface *&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryProcessorInterface *&#160;</td>
          <td class="paramname"><em>qproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryDescriptors &amp;&#160;</td>
          <td class="paramname"><em>qdescr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a query from source (query language) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">query</td><td>query interface to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analyzer</td><td>program for analyzing text segments in the query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qproc</td><td>query processor interface for info about objects loaded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qdescr</td><td>query descriptors to use in case something is not explicitely specified </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8792ff139b68a606cf703dc3121ee5b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadQueryAnalyzerProgram </td>
          <td>(</td>
          <td class="paramtype">QueryAnalyzerInterface &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryDescriptors &amp;&#160;</td>
          <td class="paramname"><em>qdescr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextProcessorInterface *&#160;</td>
          <td class="paramname"><em>textproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowIncludes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>warnings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a query analyzer program from source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">analyzer</td><td>analyzer program to instatiate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qdescr</td><td>some defaults for query language parsing filled by this procedure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">textproc</td><td>provider for text processing functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowIncludes</td><td>true if #include directives expanded, may be forbidden for security </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a3bcc86bc935dfede4346a5811764f88a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadQueryEvalProgram </td>
          <td>(</td>
          <td class="paramtype">QueryEvalInterface &amp;&#160;</td>
          <td class="paramname"><em>qeval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryDescriptors &amp;&#160;</td>
          <td class="paramname"><em>qdescr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryProcessorInterface *&#160;</td>
          <td class="paramname"><em>qproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a query evaluation program from source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qeval</td><td>query evaluation interface to instrument </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qdescr</td><td>query descriptors to instrument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qproc</td><td>query processor interface for info about objects loaded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source string (not a file name!) to parse </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8f9de377a99129c479c1c3e9eb0a88d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::loadVectorStorageVectors </td>
          <td>(</td>
          <td class="paramtype">VectorStorageClientInterface *&#160;</td>
          <td class="paramname"><em>vstorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vectorfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the feature definitions in the file with path vectorfile to a vector storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vstorage</td><td>vector storage object where to add the loaded vectors to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vectorfile</td><td>Path of the file to parse, either a google binary vector file format or text </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a class="anchor" id="ab396cf48e1a280e8fe00cd20a2500a70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::parseDocumentClass </td>
          <td>(</td>
          <td class="paramtype">analyzer::DocumentClass &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a document class from a declaration like 'content="application/xml"; charset=UTF-8"'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>returned document class </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>content type declaration </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a class="anchor" id="a4176074a811b447a92cf49bcb9e71e4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strus::scanNextProgram </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>itr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorBufferInterface *&#160;</td>
          <td class="paramname"><em>errorhnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan a source for the next program segment in a source that contains multiple programs. The programs are separated by "\r\n.\r\n" or "\n.\n". No escaping of this sequence possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">segment</td><td>the program segment scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itr</td><td>scanning iterator on a source containing one or multiple programs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>end iterator of the source to scan </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">errorhnd</td><td>buffer for reporting errors (exceptions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if there was a segment left to scan </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is mainly used for loading test programs </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The scanner skips whitespaces at the start of each program segment and returns initial end of line that belongs to the separator. So whitespaces should have no meaning in the languages of the programs loaded this way. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 6 2017 18:11:44 for strusUtilities by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
